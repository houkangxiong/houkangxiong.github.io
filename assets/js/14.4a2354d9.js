(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{295:function(a,t,_){"use strict";_.r(t);var s=_(0),v=Object(s.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"设计模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设计模式"}},[a._v("#")]),a._v(" 设计模式")]),a._v(" "),t("h2",{attrs:{id:"_1、什么是设计模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、什么是设计模式"}},[a._v("#")]),a._v(" 1、什么是设计模式")]),a._v(" "),t("p",[a._v("我们程序员在工作中总结出解决问题的思路；")]),a._v(" "),t("h2",{attrs:{id:"_2、为什么学习设计模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、为什么学习设计模式"}},[a._v("#")]),a._v(" 2、为什么学习设计模式")]),a._v(" "),t("ol",[t("li",[a._v("提高思维")]),a._v(" "),t("li",[a._v("提高效率，程序更加标准化")]),a._v(" "),t("li",[a._v("灵活性、可读性、扩展性、提高可维护性")]),a._v(" "),t("li",[a._v("更好的阅读源码")])]),a._v(" "),t("h2",{attrs:{id:"_3、类与类之间关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、类与类之间关系"}},[a._v("#")]),a._v(" 3、类与类之间关系")]),a._v(" "),t("h4",{attrs:{id:"继承关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#继承关系"}},[a._v("#")]),a._v(" 继承关系")]),a._v(" "),t("h4",{attrs:{id:"实现关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现关系"}},[a._v("#")]),a._v(" 实现关系")]),a._v(" "),t("h4",{attrs:{id:"依赖关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#依赖关系"}},[a._v("#")]),a._v(" 依赖关系")]),a._v(" "),t("p",[a._v("我们在一个类的方法中操作局部变量使用到另一个类")]),a._v(" "),t("h4",{attrs:{id:"关联关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关联关系"}},[a._v("#")]),a._v(" 关联关系")]),a._v(" "),t("p",[a._v("有"),t("strong",[a._v("单向关联")]),a._v("、"),t("strong",[a._v("双向关联")]),a._v("、"),t("strong",[a._v("自关联")]),a._v("；")]),a._v(" "),t("p",[a._v("关联关系根据紧密度我们又可以细分有：聚合关系、组合关系")]),a._v(" "),t("p",[t("strong",[a._v("聚合关系")]),a._v("：如学校和老师，学校如果没有老师还是学校、mybatis中使用过的查询；")]),a._v(" "),t("p",[t("strong",[a._v("组合关系")]),a._v("：如头和嘴巴，都互相需要对方才可以；")]),a._v(" "),t("h2",{attrs:{id:"_4、面向对象设计原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、面向对象设计原则"}},[a._v("#")]),a._v(" 4、面向对象设计原则")]),a._v(" "),t("h4",{attrs:{id:"单一职责"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单一职责"}},[a._v("#")]),a._v(" 单一职责")]),a._v(" "),t("p",[a._v("每个类都负责自己的职责，解耦")]),a._v(" "),t("h4",{attrs:{id:"开闭原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#开闭原则"}},[a._v("#")]),a._v(" 开闭原则")]),a._v(" "),t("p",[a._v("对扩展开放，对修改关闭；")]),a._v(" "),t("h4",{attrs:{id:"里氏替换"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#里氏替换"}},[a._v("#")]),a._v(" 里氏替换")]),a._v(" "),t("p",[a._v("可以扩展新方法，但不要重写父类方法；")]),a._v(" "),t("p",[a._v("透明调用，父类被使用的地方，换成子类也应该可以执行，结果不受影响；")]),a._v(" "),t("h4",{attrs:{id:"依赖倒置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#依赖倒置"}},[a._v("#")]),a._v(" 依赖倒置")]),a._v(" "),t("p",[a._v("面向接口和抽象类编程，依赖抽象而不依赖细节；")]),a._v(" "),t("h4",{attrs:{id:"接口隔离"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接口隔离"}},[a._v("#")]),a._v(" 接口隔离")]),a._v(" "),t("p",[a._v("使用多个接口，而非必须只是用单一接口，不必实现自己不需要的方法；")]),a._v(" "),t("h4",{attrs:{id:"迪米特原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#迪米特原则"}},[a._v("#")]),a._v(" 迪米特原则")]),a._v(" "),t("p",[a._v("一个对象对其他对象应该有最小的了解；")]),a._v(" "),t("p",[a._v("可以调用其他对象的公共暴露方法，而非调用对象的属性及一些细节处理；")]),a._v(" "),t("h4",{attrs:{id:"组合聚合复用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组合聚合复用"}},[a._v("#")]),a._v(" 组合聚合复用")]),a._v(" "),t("p",[a._v("需要复用方法时，通过依赖、关联来扩展，而不必继承；")]),a._v(" "),t("p",[a._v("继承的耦合度很高；")])])}),[],!1,null,null,null);t.default=v.exports}}]);